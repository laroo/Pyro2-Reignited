<!DOCTYPE html>
<html>
<head>
    <title>Pyro 2 Clone</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial; background: #222; color: white; }
        canvas { border: 2px solid #666; background: #000; }
        .controls { margin: 10px 0; }
        .score { font-size: 20px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="score">Score: <span id="score">0 (0/0 walls - 0%)</span></div>
    <canvas id="game" width="800" height="600"></canvas>
    <div class="controls">
        <p>WASD: Move (auto-lays fuse) | B: Drop Gas Can | F: Ignite Fuse</p>
    </div>

    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');

        const GRID_SIZE = 20;
        const COLS = canvas.width / GRID_SIZE;
        const ROWS = canvas.height / GRID_SIZE;

        let player = { x: 1, y: 1 };
        let score = 0;
        let fuse = [];
        let gasCans = [];
        let gas = [];
        let fires = [];
        let grid = [];
        let burning = false;
        let burnIndex = 0;
        let totalWalls = 0;
        let burnedWalls = 0;
        let gasIgnited = false;

        // Initialize grid with walls and rooms
        function initGrid() {
            for (let y = 0; y < ROWS; y++) {
                grid[y] = [];
                for (let x = 0; x < COLS; x++) {
                    if (x === 0 || y === 0 || x === COLS-1 || y === ROWS-1) {
                        grid[y][x] = 'wall';
                    } else if (Math.random() < 0.3) {
                        grid[y][x] = 'wall';
                    } else {
                        grid[y][x] = 'floor';
                    }
                }
            }
            // Ensure player start position is clear
            grid[1][1] = 'floor';
            
            // Count total walls
            totalWalls = 0;
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x] === 'wall') totalWalls++;
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const px = x * GRID_SIZE;
                    const py = y * GRID_SIZE;
                    
                    if (grid[y][x] === 'wall') {
                        ctx.fillStyle = '#666';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                    } else if (grid[y][x] === 'burned') {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                    } else if (grid[y][x] === 'burning') {
                        ctx.fillStyle = '#f80';
                        ctx.fillRect(px, py, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // Draw fuse
            fuse.forEach((f, i) => {
                if (burning && i < burnIndex) {
                    ctx.fillStyle = '#f80'; // Burned fuse
                } else {
                    ctx.fillStyle = '#ff0'; // Unburned fuse
                }
                ctx.fillRect(f.x * GRID_SIZE + 8, f.y * GRID_SIZE + 8, 4, 4);
            });

            // Draw gas
            gas.forEach(g => {
                ctx.fillStyle = gasIgnited ? '#f40' : '#0f8';
                ctx.fillRect(g.x * GRID_SIZE + 4, g.y * GRID_SIZE + 4, 12, 12);
            });

            // Draw gas cans
            ctx.fillStyle = '#f00';
            gasCans.forEach(g => {
                ctx.fillRect(g.x * GRID_SIZE + 6, g.y * GRID_SIZE + 6, 8, 8);
            });

            // Draw fires
            ctx.fillStyle = '#f80';
            fires.forEach(f => {
                ctx.fillRect(f.x * GRID_SIZE + 4, f.y * GRID_SIZE + 4, 12, 12);
            });

            // Draw player
            ctx.fillStyle = '#0f0';
            ctx.fillRect(player.x * GRID_SIZE + 2, player.y * GRID_SIZE + 2, 16, 16);
        }

        function isValidMove(x, y) {
            return x >= 0 && x < COLS && y >= 0 && y < ROWS && grid[y][x] !== 'wall';
        }

        function autoLayFuse() {
            if (grid[player.y][player.x] === 'floor' && !fuse.find(f => f.x === player.x && f.y === player.y)) {
                fuse.push({ x: player.x, y: player.y });
            }
        }

        function dropGasCan() {
            if (grid[player.y][player.x] === 'floor' && !gasCans.find(g => g.x === player.x && g.y === player.y)) {
                gasCans.push({ x: player.x, y: player.y });
                spreadGasSlowly(player.x, player.y);
            }
        }

        function spreadGasSlowly(startX, startY) {
            const visited = new Set();
            const queue = [{ x: startX, y: startY, dist: 0 }];
            let gasCount = 0;
            
            const spreadStep = () => {
                if (queue.length === 0 || gasCount >= 10) return;
                
                const { x, y, dist } = queue.shift();
                const key = `${x},${y}`;
                
                if (visited.has(key) || x < 0 || x >= COLS || y < 0 || y >= ROWS || grid[y][x] === 'wall' || dist > 3) {
                    setTimeout(spreadStep, 100);
                    return;
                }
                visited.add(key);
                
                if (!gas.find(g => g.x === x && g.y === y)) {
                    gas.push({ x, y });
                    gasCount++;
                }
                
                // Add adjacent tiles to queue
                queue.push({ x: x + 1, y, dist: dist + 1 }, { x: x - 1, y, dist: dist + 1 }, { x, y: y + 1, dist: dist + 1 }, { x, y: y - 1, dist: dist + 1 });
                
                draw();
                setTimeout(spreadStep, 100);
            };
            
            spreadStep();
        }

        function igniteFuse() {
            if (fuse.length === 0 || burning) return;
            burning = true;
            burnIndex = 0;
            burnFuseStep();
        }

        function burnFuseStep() {
            if (burnIndex >= fuse.length) {
                burning = false;
                fuse.length = 0;
                gasCans.length = 0;
                gas.length = 0;
                return;
            }

            const current = fuse[burnIndex];
            
            // Check for gas at current position
            if (gas.find(g => g.x === current.x && g.y === current.y)) {
                igniteGas();
            }

            burnIndex++;
            draw();
            setTimeout(burnFuseStep, 200);
        }

        function igniteGas() {
            gasIgnited = true;
            
            // Burn all adjacent walls to gas
            gas.forEach(g => {
                const adjacent = [
                    { x: g.x + 1, y: g.y },
                    { x: g.x - 1, y: g.y },
                    { x: g.x, y: g.y + 1 },
                    { x: g.x, y: g.y - 1 }
                ];

                adjacent.forEach(adj => {
                    if (adj.x >= 0 && adj.x < COLS && adj.y >= 0 && adj.y < ROWS && grid[adj.y][adj.x] === 'wall') {
                        grid[adj.y][adj.x] = 'burning';
                    }
                });
            });
            
            spreadFire();
        }

        function spreadFire() {
            const spreadStep = () => {
                let newFires = false;
                
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (grid[y][x] === 'burning') {
                            grid[y][x] = 'burned';
                            burnedWalls++;
                            score += 10;
                            
                            // Spread to adjacent walls
                            const adjacent = [
                                { x: x + 1, y },
                                { x: x - 1, y },
                                { x, y: y + 1 },
                                { x, y: y - 1 }
                            ];

                            adjacent.forEach(adj => {
                                if (adj.x >= 0 && adj.x < COLS && adj.y >= 0 && adj.y < ROWS && grid[adj.y][adj.x] === 'wall') {
                                    grid[adj.y][adj.x] = 'burning';
                                    newFires = true;
                                }
                            });
                        }
                    }
                }
                
                updateScore();
                draw();
                
                if (newFires) {
                    setTimeout(spreadStep, 300);
                }
            };
            
            setTimeout(spreadStep, 100);
        }

        function updateScore() {
            const percentage = totalWalls > 0 ? Math.round((burnedWalls / totalWalls) * 100) : 0;
            scoreEl.textContent = `${score} (${burnedWalls}/${totalWalls} walls - ${percentage}%)`;
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            let newX = player.x;
            let newY = player.y;

            switch(e.key.toLowerCase()) {
                case 'w': newY--; break;
                case 's': newY++; break;
                case 'a': newX--; break;
                case 'd': newX++; break;
                case 'f': igniteFuse(); break;
                case 'b': dropGasCan(); break;

            }

            if (isValidMove(newX, newY)) {
                player.x = newX;
                player.y = newY;
                autoLayFuse();
            }

            updateScore();
            draw();
        });

        // Initialize and start
        initGrid();
        draw();
    </script>
</body>
</html>